define(['dust-core', 'adaptivejs/utils'], function(dust, Utils) {

    var likeArray = function(candidate) {
        return (typeof candidate !== 'string') && (typeof candidate.length === 'number') && (!candidate.tagName);
    };

    var nodeName = function(node) {
        return node.nodeName.toLowerCase();
    };

    var escapeQuote = function(s) {
        return s.replace('"', '&quot;');
    };

    /**
     * Determines if the supplied node is a Node type, or a Node type of the node's window.
     */
    var isNode = function(node) {
        return node instanceof Node ||
                node && node.ownerDocument && node.ownerDocument.defaultView && (node instanceof node.ownerDocument.defaultView.Node);
    };

    var oldIsArray = dust.isArray;
    dust.isArray = function(arr) {
        return Boolean(arr && arr.appendTo) || oldIsArray(arr);
    };

    /**
     *  Return a string for the opening tag of DOMElement `element`.
     */
    dust.filters.openTag = function(element) {
        if (!element) {
            return '';
        }
        if (element.length) {
            element = element[0];
        }

        var stringBuffer = [];

        [].forEach.call(element.attributes, function(attr) {
            stringBuffer.push(' ', attr.name, '="', escapeQuote(attr.value), '"');
        });
        return '<' + nodeName(element) + stringBuffer.join('') + '>';
    };

    /**
     *  Return a string for the closing tag of DOMElement `element`.
     */
    dust.filters.closeTag = function(element) {
        if (!element) {
            return '';
        }
        if (element.length) {
            element = element[0];
        }

        return '</' + nodeName(element) + '>';
    };

    /**
     *  Override the behaviour of the default dust.js filter when
     *  using {key}.
     */
    dust.filters.h = function(node) {
        if (!node) {
            return '';
        }

        // Check if the node is a TextNode
        if (node.nodeType === 3) {
            if (node.nodeValue) {
                return node.nodeValue;
            }
        }

        if (isNode(node)) {
            return Utils.outerHTML(node);
        }

        if (likeArray(node)) {
            var result = [];
            for (var i = 0, len = node.length; i < len; i++) {
                result.push(dust.filters.h(node[i]));
            }
            return result.join('');
        }

        return dust.escapeHtml(node);
    };

    dust.filters.innerHTML = function(node) {
        if (!node) {
            return '';
        }
        if (likeArray(node)) {
            var result = [];
            for (var i = 0, len = node.length; i < len; i++) {
                result.push(node[i].innerHTML || node[i].nodeValue);
            }
            return result.join('');
        }
        else {
            return node.innerHTML;
        }
    };

    // Adds 'count' helper. Like idx, but this one goes to 11. It's 1 higher.
    dust.helpers.count = function(chunk, context, bodies) {
        return bodies.block(chunk, context.push(context.stack.index + 1));
    };

    /**
     *  Returns a full url for an asset including a cache breaker
     */
    dust.helpers.getUrl = function(chunk, context, bodies, params) {
        var url = Utils.getAssetUrl(params.path, params.baseUrl, params.cacheBreaker);
        return chunk.write(url);
    };

    // Override methods in Context and Chunk in order to get chain inheritance,
    // as well as for adding _SUPER_
    var Context = dust.makeBase({}).constructor;
    var Chunk = dust.stream('', {}).head.constructor;

    var oldBlock = Chunk.prototype.block;
    Chunk.prototype.block = function(elem, context, bodies) {
        var topElem = elem ? elem.shift() : undefined;
        if (topElem) {
            context.global = context.global || {};
            // Add `_SUPER_` to the block context.
            context.global._SUPER_ = function(_elem, context, _bodies) {
                return _elem.block(elem, context, bodies);
            };
            context = new context.constructor(context.stack, context.global, context.blocks);
        }

        return oldBlock.call(this, topElem, context, bodies);
    };

    Context.prototype.getBlock = function(key, chk, ctx) {
        if (typeof key === 'function') {
            var tempChk = new Chunk();
            key = key(tempChk, this).data.join('');
        }

        var blocks = this.blocks;

        if (!blocks) {
            dust.log('No blocks for context[{' + key + '}] in template [' + this.getTemplateName() + ']', 'DEBUG');
            return;
        }
        var newBlocks = [];
        for (var i = 0, len = blocks.length; i < len; i++) {
            // Only push the block if it's not undefined
            blocks[i][key] && newBlocks.push(blocks[i][key]);
        }
        return newBlocks;
    };

    return dust;
});
